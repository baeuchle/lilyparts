#!/usr/bin/python3

import argparse
import atexit
import logging
from pathlib import Path
from subprocess import run, PIPE, Popen, STDOUT

class LilySong:
    def __init__(self, path):
        self.voices = []
        self.path = self.correct_file(path)
        self.stem = self.path.stem
        self.directory = self.path.parent

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        for patt in ('*midirm', '*-midi.ps', '*-tmp-*'):
            for f in Path('.').glob(self.stem + patt):
                f.unlink(missing_ok=True)

    def __str__(self):
        return str(self.stem)

    def correct_file(self, path):
        if path.is_dir():
            path = path.with_suffix('.ly')
        if not path.exists(): # now what?
            raise AttributeError(f"Cannot open {path}")
        with path.open('r') as peek:
            for line in peek:
                if not line.strip():
                    continue
                if line[:28] == r'\include "lilyparts/head.ly"':
                    self.read_voices(peek)
                    return path
        return self.correct_file(path.parent)

    def read_voices(self, peek):
        for line in peek:
            if "calc.ly" in line:
                return
            words = line.strip().split()
            if words and words[0][:3] == 'has':
                self.voices.append(words[0][3:])

    def move(self, voice, suffix):
        source = Path(self.stem + voice).with_suffix(suffix)
        if not source.exists():
            return
        source.rename(Path(self.stem).with_suffix(suffix))

class Compiler:
    popendict = dict(stdout=PIPE, stderr=STDOUT, text=True)

    def __init__(self, song, lilycode, lilyopts):
        self.song = song
        self.sary = [args.lily_exe, *lilyopts, '-e', ' '.join(lilycode), song.path]
        self.returncode = None
        log.info("running %s", ' '.join([repr(str(x)) for x in self.sary]))

    def execute(self):
        lilyrun = Popen(self.sary, **self.popendict)
        for outline in lilyrun.stdout:
            print(outline, end='')
        self.returncode = lilyrun.wait()

class PdfCompiler(Compiler):
    def __init__(self, song, lilycode, lilyopts):
        lilyopts = lilyopts.copy()
        lilyopts.append('-dmidi-extension=midirm')
        super().__init__(song, lilycode, lilyopts)

class MidiCompiler(Compiler):
    def __init__(self, song, lilycode, lilyopts, midi_suffix):
        lilyopts = lilyopts.copy()
        lilyopts.append('--ps')
        lilyopts.append(f'-dmidi-extension={midi_suffix[1:]}')
        lilycode = lilycode.copy()
        lilycode.append('(define-public makeMidi #t)')
        super().__init__(song, lilycode, lilyopts)

class VoiceCompiler(PdfCompiler):
    def __init__(self, song, lilycode, lilyopts, voice):
        lilycode = lilycode.copy()
        lilycode.append(f'(define-public show{voice} #t)')
        super().__init__(song, lilycode, lilyopts)

def which(name):
    return Path(run(['which', name], capture_output=True, text=True).stdout.strip())

def gitdescribe(git_exe, git_opt, directory):
    return run([git_exe, '-C', directory, *git_opt], capture_output=True,
            text=True).stdout.strip()

def default_config_home():
    from os import environ
    xdghome = environ.get('XDG_CONFIG_HOME', False)
    if environ.get('XDG_CONFIG_HOME', False):
        return Path(environ.get('XDG_CONFIG_HOME'))
    home = environ.get('HOME', False)
    if not home:
        user = os.environ.get('USER', os.environ.get('LOGNAME', False))
        if not user:
            return ''
        home = Path('/home') / user
    else:
        home = Path(home)
    return home / '.config'

parser = argparse.ArgumentParser()
lilygroup = parser.add_argument_group('Lilypond execution')
lilygroup.add_argument('--lily-exe', default=which('lilypond'), type=Path)
lilygroup.add_argument('--lily-opts', nargs='*', action="extend", default=[])
lilygroup.add_argument('--lily-code', nargs='*', action="extend", default=[])
lilygroup.add_argument('--lily-loglevel', choices='NONE ERROR WARNING BASIC PROGRESS INFO DEBUG'.split(),
        default="WARNING")
execgroup = parser.add_argument_group('Execution control')
execgroup.add_argument('--color', action=argparse.BooleanOptionalAction, default=False, help="currently ignored")
execgroup.add_argument('--log-level', choices='CRITICAL ERROR WARNING INFO DEBUG'.split(), default="INFO")
gitgroup = parser.add_argument_group('Git execution')
gitgroup.add_argument('--gitexe', default=which('git'), type=Path)
gitgroup.add_argument('--gitopt', default='describe --tags --dirty --always'.split(), nargs='*')
gitgroup.add_argument('--usegit', action=argparse.BooleanOptionalAction, default=True)
parser.add_argument('--include-dir', type=Path, default=default_config_home() / 'lilyparts')
parser.add_argument('--papersize', default="a4")
parser.add_argument('--point_and_click', '--pac', action=argparse.BooleanOptionalAction,
        default=False)
parser.add_argument('--midi-suffix', default='.midi')
parser.add_argument('files', nargs='+', type=Path)
args = parser.parse_args()

logging.basicConfig(level=args.log_level)
log = logging.getLogger("lilysplit")

args.lily_opts.append('-dpoint-and-click' if args.point_and_click else '-dno-point-and-click')
args.lily_opts.extend(['--include', str(args.include_dir)])
args.lily_opts.extend(['--loglevel', args.lily_loglevel])
args.lily_code.append(f'(define-public mypapersize "{args.papersize}")')

if not args.lily_exe.exists():
    log.error("lilypond not found, please use --lily_exe /path/to/lilypond")
    raise SystemExit(1)

if args.usegit:
    lilyver = gitdescribe(args.gitexe, args.gitopt, args.include_dir)
    args.lily_code.append(f'(define-public lilyver "{lilyver}")')

versions = {}

for song in args.files:
    with LilySong(song) as lilysong:
        log.info("Looking at %s", lilysong)
        if lilysong.directory not in versions:
            versions[lilysong.directory] = gitdescribe(args.gitexe, args.gitopt, lilysong.directory)
            log.info("%s is in new directory %s with git version %s",
                     lilysong, lilysong.directory, versions[lilysong.directory])

        lilycode = args.lily_code.copy()
        lilycode.append(f'(define-public gitver "{versions[lilysong.directory]}")')

        partc = PdfCompiler(lilysong, lilycode, args.lily_opts)
        partc.execute()
        lilysong.move('-', '.pdf')
        if partc.returncode != 0:
            raise SystemExit(partc.returncode)

        midic = MidiCompiler(lilysong, lilycode, args.lily_opts, midi_suffix=args.midi_suffix)
        midic.execute()
        lilysong.move('-midi', args.midi_suffix)
        if midic.returncode != 0:
            raise SystemExit(midic.returncode)

        lilycode.append('(define-public showAlle #f)')
        for voice in lilysong.voices:
            voicec = VoiceCompiler(lilysong, lilycode, args.lily_opts, voice=voice)
            voicec.execute()
            if voicec.returncode != 0:
                raise SystemExit(voicec.returncode)
